# Zod Schema Design for MCP Servers

## Schema-First Development

Zod schemas are the foundation of your MCP server. They define data validation, type safety, and AI agent understanding.

## Basic Schema Patterns

### Simple Entity Schema
```typescript
const UserSchema = z.object({
  id: z.string().readonly(),           // Auto-generated, read-only
  name: z.string().min(1, "Name is required"),
  email: z.string().email("Invalid email format"),
  age: z.number().min(0, "Age must be non-negative"),
  createdAt: z.date().readonly(),      // Auto-set, read-only
  updatedAt: z.date().readonly(),      // Auto-updated, read-only
});

type User = z.infer<typeof UserSchema>;
```

### Complex Nested Schema
```typescript
const AddressSchema = z.object({
  street: z.string().min(1, "Street address is required"),
  city: z.string().min(1, "City is required"),
  state: z.string().length(2, "State must be 2 characters"),
  zipCode: z.string().regex(/^\d{5}(-\d{4})?$/, "Invalid ZIP code format"),
  country: z.string().default("US"),
});

const ContactSchema = z.object({
  phone: z.string().regex(/^\+?[\d\s\-\(\)]+$/, "Invalid phone number"),
  website: z.string().url("Invalid website URL").optional(),
  socialMedia: z.object({
    twitter: z.string().startsWith("@").optional(),
    linkedin: z.string().url("Invalid LinkedIn URL").optional(),
  }).optional(),
});

const UserSchema = z.object({
  id: z.string().readonly(),
  name: z.string().min(1, "Name is required"),
  email: z.string().email("Invalid email format"),
  address: AddressSchema.optional(),
  contacts: ContactSchema.optional(),
  preferences: z.object({
    newsletter: z.boolean().default(false),
    notifications: z.enum(["email", "sms", "push"]).default("email"),
    timezone: z.string().default("UTC"),
  }).default({}),
  createdAt: z.date().readonly(),
  updatedAt: z.date().readonly(),
});
```

## Schema Validation Patterns

### Input Validation Schemas
```typescript
// Separate schemas for different operations
const CreateUserSchema = UserSchema.omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

const UpdateUserSchema = CreateUserSchema.partial(); // All fields optional

const UserQuerySchema = z.object({
  name: z.string().optional(),
  email: z.string().email().optional(),
  ageMin: z.number().min(0).optional(),
  ageMax: z.number().min(0).optional(),
  hasAddress: z.boolean().optional(),
  preferences: z.object({
    newsletter: z.boolean().optional(),
    notifications: z.enum(["email", "sms", "push"]).optional(),
  }).optional(),
  limit: z.number().min(1).max(100).default(20),
  offset: z.number().min(0).default(0),
});

// Use in handlers
create: {
  description: "Create a new user",
  inputSchema: CreateUserSchema,
  handler: async (data) => {
    // data is fully validated and typed
    const user = await createUser(data);
    return user;
  },
},

search: {
  description: "Search users with filters",
  inputSchema: UserQuerySchema,
  handler: async (query) => {
    // query is validated with defaults applied
    return await searchUsers(query);
  },
}
```

### Advanced Validation
```typescript
const NoteSchema = z.object({
  id: z.string().readonly(),
  title: z.string()
    .min(1, "Title is required")
    .max(200, "Title must be less than 200 characters")
    .trim(),
  content: z.string()
    .min(10, "Content must be at least 10 characters")
    .max(10000, "Content must be less than 10,000 characters"),
  tags: z.array(z.string())
    .min(1, "At least one tag is required")
    .max(10, "Maximum 10 tags allowed")
    .transform(tags => tags.map(tag => tag.toLowerCase().trim())),
  priority: z.enum(["low", "medium", "high"])
    .default("medium"),
  dueDate: z.date()
    .min(new Date(), "Due date must be in the future")
    .optional(),
  status: z.enum(["draft", "in_progress", "completed", "archived"])
    .default("draft"),
  metadata: z.record(z.unknown()).optional(), // Flexible metadata
  createdAt: z.date().readonly(),
  updatedAt: z.date().readonly(),
});
```

## Schema Relationships

### Referential Integrity
```typescript
const CategorySchema = z.object({
  id: z.string().readonly(),
  name: z.string().min(1, "Category name is required"),
  description: z.string().optional(),
  parentId: z.string().optional(), // Self-referencing for hierarchy
  createdAt: z.date().readonly(),
});

const NoteSchema = z.object({
  id: z.string().readonly(),
  title: z.string().min(1, "Title is required"),
  content: z.string().min(1, "Content is required"),
  categoryId: z.string().min(1, "Category is required"),
  authorId: z.string().min(1, "Author is required"),
  tags: z.array(z.string()).default([]),
  createdAt: z.date().readonly(),
  updatedAt: z.date().readonly(),
});

// Validate relationships exist
const validateNoteRelations = async (data: z.infer<typeof NoteSchema>) => {
  const [category, author] = await Promise.all([
    db.categories.findById(data.categoryId),
    db.users.findById(data.authorId),
  ]);
  
  if (!category) throw new Error("Category not found");
  if (!category) throw new Error("Author not found");
  
  return { category, author };
};
```

### Polymorphic Relationships
```typescript
const AttachmentSchema = z.object({
  id: z.string().readonly(),
  filename: z.string().min(1, "Filename is required"),
  mimeType: z.string().min(1, "MIME type is required"),
  size: z.number().positive("File size must be positive"),
  url: z.string().url("Invalid URL"),
  entityType: z.enum(["note", "user", "category"]),
  entityId: z.string().min(1, "Entity ID is required"),
  createdAt: z.date().readonly(),
});

// Validate entity exists based on type
const validateAttachmentEntity = async (data: z.infer<typeof AttachmentSchema>) => {
  let entity;
  
  switch (data.entityType) {
    case "note":
      entity = await db.notes.findById(data.entityId);
      break;
    case "user":
      entity = await db.users.findById(data.entityId);
      break;
    case "category":
      entity = await db.categories.findById(data.entityId);
      break;
    default:
      throw new Error("Invalid entity type");
  }
  
  if (!entity) throw new Error(`${data.entityType} not found`);
  return entity;
};
```

## Schema Transformation and Coercion

### Data Transformation
```typescript
const UserInputSchema = z.object({
  name: z.string().min(1).transform(name => name.trim()),
  email: z.string().email().transform(email => email.toLowerCase()),
  age: z.coerce.number().min(0).max(120), // Coerce string to number
  birthDate: z.string().transform(str => new Date(str)), // Coerce string to Date
  preferences: z.string().transform(str => JSON.parse(str)), // Coerce JSON string
});

// Use in handler
handler: async (rawData) => {
  // Transform and validate input
  const data = UserInputSchema.parse(rawData);
  
  // data is now properly typed and transformed
  const user = await createUser(data);
  return user;
}
```

### Conditional Validation
```typescript
const UserSchema = z.object({
  id: z.string().readonly(),
  name: z.string().min(1),
  email: z.string().email(),
  accountType: z.enum(["free", "premium", "enterprise"]),
  
  // Conditional fields based on account type
  subscription: z.object({
    plan: z.string(),
    expiresAt: z.date(),
    features: z.array(z.string()),
  }).optional().refine(
    (subscription) => {
      // Premium accounts must have subscription
      return accountType !== "premium" || subscription !== undefined;
    },
    { message: "Premium accounts require subscription" }
  ),
  
  // Enterprise accounts have additional requirements
  enterprise: z.object({
    companyName: z.string().min(1),
    adminEmail: z.string().email(),
    ssoEnabled: z.boolean(),
  }).optional().refine(
    (enterprise) => {
      return accountType !== "enterprise" || enterprise !== undefined;
    },
    { message: "Enterprise accounts require company information" }
  ),
});
```

## Schema Composition and Reuse

### Base Schemas
```typescript
const BaseEntitySchema = z.object({
  id: z.string().readonly(),
  createdAt: z.date().readonly(),
  updatedAt: z.date().readonly(),
});

const AuditableSchema = BaseEntitySchema.extend({
  createdBy: z.string().min(1),
  updatedBy: z.string().min(1),
  version: z.number().positive(),
});

// Extend base schemas
const UserSchema = AuditableSchema.extend({
  name: z.string().min(1),
  email: z.string().email(),
  // ... other user fields
});

const NoteSchema = AuditableSchema.extend({
  title: z.string().min(1),
  content: z.string().min(1),
  // ... other note fields
});
```

### Schema Merging
```typescript
const CreateUserSchema = UserSchema.omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  createdBy: true,
  updatedBy: true,
  version: true,
});

const UpdateUserSchema = CreateUserSchema.partial();

// Merge with additional validation
const CreateUserWithValidationSchema = CreateUserSchema.merge(
  z.object({
    password: z.string().min(8, "Password must be at least 8 characters"),
    confirmPassword: z.string(),
  })
).refine(
  (data) => data.password === data.confirmPassword,
  { message: "Passwords don't match", path: ["confirmPassword"] }
);
```

## Best Practices

1. **Descriptive Error Messages**: Use clear, actionable error messages
2. **Schema Composition**: Build complex schemas from simple, reusable parts
3. **Input/Output Separation**: Use different schemas for input validation vs output
4. **Relationship Validation**: Always validate that referenced entities exist
5. **Type Safety**: Leverage TypeScript inference for compile-time safety
6. **Performance**: Use `.transform()` for expensive operations, `.refine()` for validation
7. **Documentation**: Use `.describe()` for AI agent understanding
8. **Default Values**: Provide sensible defaults where appropriate
9. **Coercion**: Use `.coerce` for safe type conversions
10. **Testing**: Test your schemas with various input scenarios
description: Zod schema design patterns and best practices for MCP servers
globs: ["**/*.ts", "**/*.tsx"]
alwaysApply: false
---
